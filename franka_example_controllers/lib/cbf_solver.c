/* This file was automatically generated by CasADi 3.6.7.
 *  It consists of: 
 *   1) content generated by CasADi runtime: not copyrighted
 *   2) template code copied from CasADi source: permissively licensed (MIT-0)
 *   3) user code: owned by the user
 *
 */
#ifdef __cplusplus
extern "C" {
#endif

/* How to prefix internal symbols */
#ifdef CASADI_CODEGEN_PREFIX
  #define CASADI_NAMESPACE_CONCAT(NS, ID) _CASADI_NAMESPACE_CONCAT(NS, ID)
  #define _CASADI_NAMESPACE_CONCAT(NS, ID) NS ## ID
  #define CASADI_PREFIX(ID) CASADI_NAMESPACE_CONCAT(CODEGEN_PREFIX, ID)
#else
  #define CASADI_PREFIX(ID) cbf_solver_ ## ID
#endif

#include <math.h>
#include <coin-or/IpStdCInterface.h>

#ifndef casadi_real
#define casadi_real double
#endif

#ifndef casadi_int
#define casadi_int long long int
#endif

#ifndef CASADI_MAX_NUM_THREADS
#define CASADI_MAX_NUM_THREADS 1
#endif

/* Add prefix to internal symbols */
#define casadi_clear CASADI_PREFIX(clear)
#define casadi_copy CASADI_PREFIX(copy)
#define casadi_densify CASADI_PREFIX(densify)
#define casadi_f0 CASADI_PREFIX(f0)
#define casadi_f1 CASADI_PREFIX(f1)
#define casadi_f1_alloc_mem CASADI_PREFIX(f1_alloc_mem)
#define casadi_f1_init_mem CASADI_PREFIX(f1_init_mem)
#define casadi_f1_mem CASADI_PREFIX(f1_mem)
#define casadi_f1_mem_counter CASADI_PREFIX(f1_mem_counter)
#define casadi_f1_unused_stack CASADI_PREFIX(f1_unused_stack)
#define casadi_f1_unused_stack_counter CASADI_PREFIX(f1_unused_stack_counter)
#define casadi_f2 CASADI_PREFIX(f2)
#define casadi_f3 CASADI_PREFIX(f3)
#define casadi_f4 CASADI_PREFIX(f4)
#define casadi_f5 CASADI_PREFIX(f5)
#define casadi_f6 CASADI_PREFIX(f6)
#define casadi_f7 CASADI_PREFIX(f7)
#define casadi_f8 CASADI_PREFIX(f8)
#define casadi_fill CASADI_PREFIX(fill)
#define casadi_fmax CASADI_PREFIX(fmax)
#define casadi_ipopt_data CASADI_PREFIX(ipopt_data)
#define casadi_ipopt_free_mem CASADI_PREFIX(ipopt_free_mem)
#define casadi_ipopt_hess_l_empty CASADI_PREFIX(ipopt_hess_l_empty)
#define casadi_ipopt_init CASADI_PREFIX(ipopt_init)
#define casadi_ipopt_init_mem CASADI_PREFIX(ipopt_init_mem)
#define casadi_ipopt_presolve CASADI_PREFIX(ipopt_presolve)
#define casadi_ipopt_setup CASADI_PREFIX(ipopt_setup)
#define casadi_ipopt_solve CASADI_PREFIX(ipopt_solve)
#define casadi_ipopt_sparsity CASADI_PREFIX(ipopt_sparsity)
#define casadi_ipopt_work CASADI_PREFIX(ipopt_work)
#define casadi_mtimes CASADI_PREFIX(mtimes)
#define casadi_nlp_f0 CASADI_PREFIX(nlp_f0)
#define casadi_nlp_g0 CASADI_PREFIX(nlp_g0)
#define casadi_nlp_grad_f0 CASADI_PREFIX(nlp_grad_f0)
#define casadi_nlp_hess_l0 CASADI_PREFIX(nlp_hess_l0)
#define casadi_nlp_jac_g0 CASADI_PREFIX(nlp_jac_g0)
#define casadi_nlpsol_data CASADI_PREFIX(nlpsol_data)
#define casadi_nlpsol_detect_bounds_after CASADI_PREFIX(nlpsol_detect_bounds_after)
#define casadi_nlpsol_detect_bounds_before CASADI_PREFIX(nlpsol_detect_bounds_before)
#define casadi_nlpsol_detect_bounds_data CASADI_PREFIX(nlpsol_detect_bounds_data)
#define casadi_nlpsol_detect_bounds_prob CASADI_PREFIX(nlpsol_detect_bounds_prob)
#define casadi_nlpsol_init CASADI_PREFIX(nlpsol_init)
#define casadi_nlpsol_prob CASADI_PREFIX(nlpsol_prob)
#define casadi_nlpsol_work CASADI_PREFIX(nlpsol_work)
#define casadi_oracle_data CASADI_PREFIX(oracle_data)
#define casadi_oracle_init CASADI_PREFIX(oracle_init)
#define casadi_s0 CASADI_PREFIX(s0)
#define casadi_s1 CASADI_PREFIX(s1)
#define casadi_s10 CASADI_PREFIX(s10)
#define casadi_s11 CASADI_PREFIX(s11)
#define casadi_s12 CASADI_PREFIX(s12)
#define casadi_s13 CASADI_PREFIX(s13)
#define casadi_s14 CASADI_PREFIX(s14)
#define casadi_s2 CASADI_PREFIX(s2)
#define casadi_s3 CASADI_PREFIX(s3)
#define casadi_s4 CASADI_PREFIX(s4)
#define casadi_s5 CASADI_PREFIX(s5)
#define casadi_s6 CASADI_PREFIX(s6)
#define casadi_s7 CASADI_PREFIX(s7)
#define casadi_s8 CASADI_PREFIX(s8)
#define casadi_s9 CASADI_PREFIX(s9)
#define casadi_scal CASADI_PREFIX(scal)
#define casadi_sparsify CASADI_PREFIX(sparsify)
#define casadi_trans CASADI_PREFIX(trans)

/* Symbol visibility in DLLs */
#ifndef CASADI_SYMBOL_EXPORT
  #if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
    #if defined(STATIC_LINKED)
      #define CASADI_SYMBOL_EXPORT
    #else
      #define CASADI_SYMBOL_EXPORT __declspec(dllexport)
    #endif
  #elif defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
    #define CASADI_SYMBOL_EXPORT __attribute__ ((visibility ("default")))
  #else
    #define CASADI_SYMBOL_EXPORT
  #endif
#endif

void casadi_fill(casadi_real* x, casadi_int n, casadi_real alpha) {
  casadi_int i;
  if (x) {
    for (i=0; i<n; ++i) *x++ = alpha;
  }
}

void casadi_clear(casadi_real* x, casadi_int n) {
  casadi_int i;
  if (x) {
    for (i=0; i<n; ++i) *x++ = 0;
  }
}

void casadi_copy(const casadi_real* x, casadi_int n, casadi_real* y) {
  casadi_int i;
  if (y) {
    if (x) {
      for (i=0; i<n; ++i) *y++ = *x++;
    } else {
      for (i=0; i<n; ++i) *y++ = 0.;
    }
  }
}

#define CASADI_CAST(x,y) ((x) y)

void casadi_densify(const casadi_real* x, const casadi_int* sp_x, casadi_real* y, casadi_int tr) {
  casadi_int nrow_x, ncol_x, i, el;
  const casadi_int *colind_x, *row_x;
  if (!y) return;
  nrow_x = sp_x[0]; ncol_x = sp_x[1];
  colind_x = sp_x+2; row_x = sp_x+ncol_x+3;
  casadi_clear(y, nrow_x*ncol_x);
  if (!x) return;
  if (tr) {
    for (i=0; i<ncol_x; ++i) {
      for (el=colind_x[i]; el!=colind_x[i+1]; ++el) {
        y[i + row_x[el]*ncol_x] = CASADI_CAST(casadi_real, *x++);
      }
    }
  } else {
    for (i=0; i<ncol_x; ++i) {
      for (el=colind_x[i]; el!=colind_x[i+1]; ++el) {
        y[row_x[el]] = CASADI_CAST(casadi_real, *x++);
      }
      y += nrow_x;
    }
  }
}

struct casadi_oracle_data {
  const casadi_real** arg;
  casadi_real** res;
  casadi_int* iw;
  casadi_real* w;
  void* m;
};
void casadi_oracle_init(struct casadi_oracle_data* d, const casadi_real*** arg, casadi_real*** res,
    casadi_int** iw, casadi_real** w) {
  d->arg = *arg;
  d->res = *res;
  d->iw = *iw;
  d->w = *w;
}

struct casadi_nlpsol_detect_bounds_prob {
  casadi_int sz_arg;
  casadi_int sz_res;
  casadi_int sz_iw;
  casadi_int sz_w;
  casadi_int ng;
  casadi_int nb;
  const casadi_int *target_x;
  const casadi_int *target_g;
  const char *is_simple;
  int (*callback)(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, void* callback_data);
  void* callback_data;
};
struct casadi_nlpsol_prob {
  casadi_int nx, ng, np;
  struct casadi_nlpsol_detect_bounds_prob detect_bounds;
};
struct casadi_nlpsol_detect_bounds_data {
  const casadi_real** arg;
  casadi_real** res;
  casadi_int* iw;
  casadi_real* w;
  casadi_real* a;
  casadi_real* b;
  casadi_int* target_l;
  casadi_int* target_u;
  casadi_real* lam_xl;
  casadi_real* lam_xu;
};
struct casadi_nlpsol_data {
  const struct casadi_nlpsol_prob* prob;
  struct casadi_oracle_data* oracle;
  casadi_real *lbz, *ubz;
  casadi_real *z;
  casadi_real *lam;
  casadi_real objective;
  const casadi_real *p, *lbx, *ubx, *lbg, *ubg, *x0, *lam_x0, *lam_g0;
  casadi_real *f, *x, *g, *lam_x, *lam_g, *lam_p;
  struct casadi_nlpsol_detect_bounds_data detect_bounds;
};
void casadi_nlpsol_work(const struct casadi_nlpsol_prob* p, casadi_int* sz_arg, casadi_int* sz_res,
    casadi_int* sz_iw, casadi_int* sz_w) {
  *sz_arg = *sz_res = 0;
  *sz_w = *sz_iw = 0;
  *sz_w += p->nx + p->ng;
  *sz_w += p->nx + p->ng;
  *sz_w += p->nx + p->ng;
  *sz_w += p->nx + p->ng;
  if (p->detect_bounds.ng) {
    *sz_arg += p->detect_bounds.sz_arg;
    *sz_res += p->detect_bounds.sz_res;
    *sz_iw += p->detect_bounds.sz_iw;
    *sz_w += p->detect_bounds.sz_w;
    *sz_w += p->detect_bounds.nb;
    *sz_w += p->detect_bounds.nb;
    *sz_iw += p->nx;
    *sz_iw += p->nx;
    *sz_w += p->nx;
    *sz_w += p->nx;
  }
}
void casadi_nlpsol_init(struct casadi_nlpsol_data* d, const casadi_real*** arg, casadi_real*** res,
    casadi_int** iw, casadi_real** w) {
  casadi_int nx, ng;
  const struct casadi_nlpsol_prob* p = d->prob;
  nx = p->nx;
  ng = p->ng;
  d->z = *w; *w += nx + ng;
  d->lbz = *w; *w += nx + ng;
  d->ubz = *w; *w += nx + ng;
  d->lam = *w; *w += nx + ng;
  if (p->detect_bounds.ng) {
    d->detect_bounds.arg = *arg; *arg += p->detect_bounds.sz_arg;
    d->detect_bounds.res = *res; *res += p->detect_bounds.sz_res;
    d->detect_bounds.iw = *iw; *iw += p->detect_bounds.sz_iw;
    d->detect_bounds.w = *w; *w += p->detect_bounds.sz_w;
    d->detect_bounds.a = *w; *w += p->detect_bounds.nb;
    d->detect_bounds.b = *w; *w += p->detect_bounds.nb;
    d->detect_bounds.target_l = *iw; *iw += p->nx;
    d->detect_bounds.target_u = *iw; *iw += p->nx;
    d->detect_bounds.lam_xl = *w; *w += nx;
    d->detect_bounds.lam_xu = *w; *w += nx;
  }
}
int casadi_detect_bounds_before(struct casadi_nlpsol_data* d_nlp) {
  const struct casadi_nlpsol_prob* p_nlp = d_nlp->prob;
  struct casadi_nlpsol_detect_bounds_data* d_bounds = &d_nlp->detect_bounds;
  const struct casadi_nlpsol_detect_bounds_prob* p_bounds = &p_nlp->detect_bounds;
  casadi_int nx = p_nlp->nx;
  d_bounds->arg[0] = d_nlp->p;
  d_bounds->res[0] = d_bounds->a;
  d_bounds->res[1] = d_bounds->b;
  p_bounds->callback(d_bounds->arg, d_bounds->res,
    d_bounds->iw, d_bounds->w, p_bounds->callback_data);
  for (casadi_int i=0;i<p_bounds->nb;++i) {
    if (d_bounds->a[i]==0) {
      casadi_int k = p_bounds->target_g[i];
      if (d_nlp->lbg[k]>d_bounds->b[i]) return 1;
      if (d_nlp->ubg[k]<d_bounds->b[i]) return 1;
    }
  }
  casadi_real* lbz = d_nlp->lbz+nx;
  casadi_real* ubz = d_nlp->ubz+nx;
  casadi_real* lam = d_nlp->lam+nx;
  for (casadi_int i=0;i<nx;++i) {
    d_bounds->lam_xl[i] = d_nlp->lam_x0 ? (d_nlp->lam_x0[i]<0)*d_nlp->lam_x0[i] : 0.;
    d_bounds->lam_xu[i] = d_nlp->lam_x0 ? (d_nlp->lam_x0[i]>0)*d_nlp->lam_x0[i] : 0.;
  }
  for (casadi_int i=0;i<nx;++i) {
    d_bounds->target_l[i] = i;
    d_bounds->target_u[i] = i;
  }
  casadi_int k=0;
  for (casadi_int i=0;i<p_bounds->ng;++i) {
    if (p_bounds->is_simple[i]) {
      casadi_real lb = (d_nlp->lbg[i]-d_bounds->b[k])/d_bounds->a[k];
      casadi_real ub = (d_nlp->ubg[i]-d_bounds->b[k])/d_bounds->a[k];
      if (d_bounds->a[k]<0) {
        casadi_real tmp = lb;
        lb = ub;
        ub = tmp;
      }
      casadi_int j = p_bounds->target_x[k];
      if (lb==d_nlp->lbz[j]) {
        if (d_nlp->lam_g0) d_bounds->lam_xl[j] += (d_nlp->lam_g0[i]<0)*d_nlp->lam_g0[i];
      } else if (lb>d_nlp->lbz[j]) {
        d_nlp->lbz[j] = lb;
        d_bounds->target_l[j] = nx+i;
        if (d_nlp->lam_g0) d_bounds->lam_xl[j] = (d_nlp->lam_g0[i]<0)*d_nlp->lam_g0[i];
      }
      if (ub==d_nlp->ubz[j]) {
        if (d_nlp->lam_g0) d_bounds->lam_xu[j] += (d_nlp->lam_g0[i]>0)*d_nlp->lam_g0[i];
      } else if (ub<d_nlp->ubz[j]) {
        d_nlp->ubz[j] = ub;
        d_bounds->target_u[j] = nx+i;
        if (d_nlp->lam_g0) d_bounds->lam_xu[j] = (d_nlp->lam_g0[i]>0)*d_nlp->lam_g0[i];
      }
      k++;
    } else {
      *lbz++ = d_nlp->lbg[i];
      *ubz++ = d_nlp->ubg[i];
      if (d_nlp->lam_g0) *lam++ = d_nlp->lam_g0[i];
    }
  }
  for (casadi_int i=0;i<nx;++i) {
    d_nlp->lam[i] = d_bounds->lam_xl[i]+d_bounds->lam_xu[i];
  }
  return 0;
}
int casadi_detect_bounds_after(struct casadi_nlpsol_data* d_nlp) {
  const struct casadi_nlpsol_prob* p_nlp = d_nlp->prob;
  struct casadi_nlpsol_detect_bounds_data* d_bounds = &d_nlp->detect_bounds;
  const struct casadi_nlpsol_detect_bounds_prob* p_bounds = &p_nlp->detect_bounds;
  casadi_int nx = p_nlp->nx;
  casadi_fill(d_nlp->lam_x, nx, 0.);
  casadi_fill(d_nlp->lam_g, p_bounds->ng, 0.);
  casadi_int k = 0;
  casadi_int k_normal = 0;
  for (casadi_int i=0;i<p_bounds->ng;++i) {
    if (p_bounds->is_simple[i]) {
      casadi_int j = p_bounds->target_x[k];
      if (d_nlp->g) d_nlp->g[i] = d_bounds->a[k]*d_nlp->z[j]+d_bounds->b[k];
      k++;
    } else {
      if (d_nlp->g) d_nlp->g[i] = d_nlp->z[nx+k_normal];
      if (d_nlp->lam_g) d_nlp->lam_g[i] = d_nlp->lam[nx+k_normal];
      k_normal++;
    }
  }
  for (casadi_int i=0;i<nx;++i) {
    if (d_bounds->target_l[i]<nx) {
      if (d_nlp->lam_x) d_nlp->lam_x[i] += (d_nlp->lam[i]<0)*d_nlp->lam[i];
    } else {
      if (d_nlp->lam_g)
        d_nlp->lam_g[d_bounds->target_l[i]-nx] += (d_nlp->lam[i]<0)*d_nlp->lam[i];
    }
    if (d_bounds->target_u[i]<nx) {
      if (d_nlp->lam_x) d_nlp->lam_x[i] += (d_nlp->lam[i]>0)*d_nlp->lam[i];
    } else {
      if (d_nlp->lam_g)
        d_nlp->lam_g[d_bounds->target_u[i]-nx] += (d_nlp->lam[i]>0)*d_nlp->lam[i];
    }
  }
  k = 0;
  for (casadi_int i=0;i<p_bounds->ng;++i) {
    if (p_bounds->is_simple[i]) {
      if (d_nlp->lam_g) d_nlp->lam_g[i] /= d_bounds->a[k];
      k++;
    }
  }
  return 0;
}

casadi_real casadi_fmax(casadi_real x, casadi_real y) {
/* Pre-c99 compatibility */
#if __STDC_VERSION__ < 199901L
  return x>y ? x : y;
#else
  return fmax(x, y);
#endif
}

void casadi_trans(const casadi_real* x, const casadi_int* sp_x, casadi_real* y,
    const casadi_int* sp_y, casadi_int* tmp) {
  casadi_int ncol_x, nnz_x, ncol_y, k;
  const casadi_int* row_x, *colind_y;
  ncol_x = sp_x[1];
  nnz_x = sp_x[2 + ncol_x];
  row_x = sp_x + 2 + ncol_x+1;
  ncol_y = sp_y[1];
  colind_y = sp_y+2;
  for (k=0; k<ncol_y; ++k) tmp[k] = colind_y[k];
  for (k=0; k<nnz_x; ++k) {
    y[tmp[row_x[k]]++] = x[k];
  }
}

void casadi_mtimes(const casadi_real* x, const casadi_int* sp_x, const casadi_real* y, const casadi_int* sp_y, casadi_real* z, const casadi_int* sp_z, casadi_real* w, casadi_int tr) {
  casadi_int ncol_x, ncol_y, ncol_z, cc;
  const casadi_int *colind_x, *row_x, *colind_y, *row_y, *colind_z, *row_z;
  ncol_x = sp_x[1];
  colind_x = sp_x+2; row_x = sp_x + 2 + ncol_x+1;
  ncol_y = sp_y[1];
  colind_y = sp_y+2; row_y = sp_y + 2 + ncol_y+1;
  ncol_z = sp_z[1];
  colind_z = sp_z+2; row_z = sp_z + 2 + ncol_z+1;
  if (tr) {
    for (cc=0; cc<ncol_z; ++cc) {
      casadi_int kk;
      for (kk=colind_y[cc]; kk<colind_y[cc+1]; ++kk) {
        w[row_y[kk]] = y[kk];
      }
      for (kk=colind_z[cc]; kk<colind_z[cc+1]; ++kk) {
        casadi_int kk1;
        casadi_int rr = row_z[kk];
        for (kk1=colind_x[rr]; kk1<colind_x[rr+1]; ++kk1) {
          z[kk] += x[kk1] * w[row_x[kk1]];
        }
      }
    }
  } else {
    for (cc=0; cc<ncol_y; ++cc) {
      casadi_int kk;
      for (kk=colind_z[cc]; kk<colind_z[cc+1]; ++kk) {
        w[row_z[kk]] = z[kk];
      }
      for (kk=colind_y[cc]; kk<colind_y[cc+1]; ++kk) {
        casadi_int kk1;
        casadi_int rr = row_y[kk];
        for (kk1=colind_x[rr]; kk1<colind_x[rr+1]; ++kk1) {
          w[row_x[kk1]] += x[kk1]*y[kk];
        }
      }
      for (kk=colind_z[cc]; kk<colind_z[cc+1]; ++kk) {
        z[kk] = w[row_z[kk]];
      }
    }
  }
}

void casadi_sparsify(const casadi_real* x, casadi_real* y, const casadi_int* sp_y, casadi_int tr) {
  casadi_int nrow_y, ncol_y, i, el;
  const casadi_int *colind_y, *row_y;
  nrow_y = sp_y[0];
  ncol_y = sp_y[1];
  colind_y = sp_y+2; row_y = sp_y+ncol_y+3;
  if (tr) {
    for (i=0; i<ncol_y; ++i) {
      for (el=colind_y[i]; el!=colind_y[i+1]; ++el) {
        *y++ = CASADI_CAST(casadi_real, x[i + row_y[el]*ncol_y]);
      }
    }
  } else {
    for (i=0; i<ncol_y; ++i) {
      for (el=colind_y[i]; el!=colind_y[i+1]; ++el) {
        *y++ = CASADI_CAST(casadi_real, x[row_y[el]]);
      }
      x += nrow_y;
    }
  }
}

struct casadi_ipopt_prob {
  const struct casadi_nlpsol_prob* nlp;
  const casadi_int *sp_h, *sp_a;
  casadi_int nnz_h, nnz_a;
  Eval_F_CB eval_f;
  Eval_G_CB eval_g;
  Eval_Grad_F_CB eval_grad_f;
  Eval_Jac_G_CB eval_jac_g;
  Eval_H_CB eval_h;
};
void casadi_ipopt_setup(struct casadi_ipopt_prob* p) {
  if (p->sp_h) {
    p->nnz_h = p->sp_h[2+p->sp_h[1]];
  } else {
    p->nnz_h = 0;
  }
  p->nnz_a = p->sp_a[2+p->sp_a[1]];
}
struct casadi_ipopt_data {
  const struct casadi_ipopt_prob* prob;
  struct casadi_nlpsol_data* nlp;
  IpoptProblem ipopt;
  const casadi_real** arg;
  casadi_real** res;
  casadi_int* iw;
  casadi_real* w;
  casadi_real *z_L, *z_U;
  enum ApplicationReturnStatus status;
  int unified_return_status;
  int success;
};
int ipopt_init_mem(struct casadi_ipopt_data* d) {
  return 0;
}
void ipopt_free_mem(struct casadi_ipopt_data* d) {
}
void casadi_ipopt_work(const struct casadi_ipopt_prob* p, casadi_int* sz_arg, casadi_int* sz_res, casadi_int* sz_iw, casadi_int* sz_w) {
  casadi_nlpsol_work(p->nlp, sz_arg, sz_res, sz_iw, sz_w);
  *sz_w += p->nlp->nx;
  *sz_w += p->nlp->nx;
}
void casadi_ipopt_init(struct casadi_ipopt_data* d, const casadi_real*** arg, casadi_real*** res, casadi_int** iw, casadi_real** w) {
  const struct casadi_ipopt_prob* p = d->prob;
  const struct casadi_nlpsol_prob* p_nlp = p->nlp;
  d->z_L = *w; *w += p_nlp->nx;
  d->z_U = *w; *w += p_nlp->nx;
  d->arg = *arg;
  d->res = *res;
  d->iw = *iw;
  d->w = *w;
}
void casadi_ipopt_presolve(struct casadi_ipopt_data* d) {
  const struct casadi_ipopt_prob* p = d->prob;
  const struct casadi_nlpsol_prob* p_nlp = p->nlp;
  const struct casadi_nlpsol_data* d_nlp = d->nlp;
  d->ipopt = CreateIpoptProblem(
                p_nlp->nx, (double *) d_nlp->lbz, (double *) d_nlp->ubz,
                p_nlp->ng, (double *) d_nlp->lbz+p_nlp->nx,
                           (double *) d_nlp->ubz+p_nlp->nx,
                p->nnz_a, p->nnz_h, 0,
                p->eval_f, p->eval_g, p->eval_grad_f,
                p->eval_jac_g, p->eval_h);
}
void casadi_ipopt_solve(struct casadi_ipopt_data* d) {
  const struct casadi_ipopt_prob* p = d->prob;
  const struct casadi_nlpsol_prob* p_nlp = p->nlp;
  struct casadi_nlpsol_data* d_nlp = d->nlp;
  d->unified_return_status = 1;
  for (casadi_int i=0; i<p_nlp->nx; ++i) {
    d->z_L[i] = casadi_fmax(0., -d_nlp->lam[i]);
    d->z_U[i] = casadi_fmax(0., d_nlp->lam[i]);
  }
  d->status = IpoptSolve(d->ipopt, d_nlp->z, d_nlp->z + p_nlp->nx, &d_nlp->objective, d_nlp->lam+p_nlp->nx, d->z_L, d->z_U, d);
  for (casadi_int i=0; i<p_nlp->nx; ++i) {
    d_nlp->lam[i] = d->z_U[i]-d->z_L[i];
  }
  FreeIpoptProblem(d->ipopt);
  if (d->status==Solve_Succeeded ||
      d->status==Solved_To_Acceptable_Level ||
      d->status==Feasible_Point_Found) {
        d->unified_return_status = 0;
  } else if (d->status==Maximum_Iterations_Exceeded) {
      d->unified_return_status = 2;
  }
  #if (IPOPT_VERSION_MAJOR > 3) || (IPOPT_VERSION_MAJOR == 3 && IPOPT_VERSION_MINOR >= 14)
    if (d->status==Maximum_WallTime_Exceeded) d->unified_return_status = 2;
  #endif
  d->success = (d->unified_return_status == 0);
}
void casadi_ipopt_sparsity(const casadi_int* sp, ipindex *iRow, ipindex *jCol) {
    casadi_int ncol = sp[1];
    const casadi_int* colind = sp+2;
    const casadi_int* row = colind+ncol+1;
    for (casadi_int cc=0; cc<ncol; ++cc) {
        for (casadi_int el=colind[cc]; el<colind[cc+1]; ++el) {
            *iRow++ = row[el];
            *jCol++ = cc;
        }
    }
}
bool casadi_ipopt_hess_l_empty(ipindex n, ipnumber *x, bool new_x, ipnumber obj_factor, ipindex m, ipnumber *lambda, bool new_lambda, ipindex nele_hess, ipindex *iRow, ipindex *jCol, ipnumber *values, UserDataPtr user_data) {
  return false;
}

void casadi_scal(casadi_int n, casadi_real alpha, casadi_real* x) {
  casadi_int i;
  if (!x) return;
  for (i=0; i<n; ++i) *x++ *= alpha;
}

static int casadi_f1_mem_counter = 0;
static int casadi_f1_unused_stack_counter = -1;
static int casadi_f1_unused_stack[CASADI_MAX_NUM_THREADS];
static struct casadi_ipopt_data casadi_f1_mem[CASADI_MAX_NUM_THREADS];

#ifndef casadi_inf
  #define casadi_inf INFINITY
#endif

static const casadi_int casadi_s0[67] = {64, 1, 0, 63, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62};
static const casadi_int casadi_s1[24] = {8, 7, 0, 2, 4, 6, 8, 10, 12, 14, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7};
static const casadi_int casadi_s2[25] = {7, 8, 0, 7, 8, 9, 10, 11, 12, 13, 14, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6};
static const casadi_int casadi_s3[17] = {1, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0, 0, 0, 0, 0, 0, 0};
static const casadi_int casadi_s4[59] = {7, 7, 0, 7, 14, 21, 28, 35, 42, 49, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6};
static const casadi_int casadi_s5[11] = {1, 7, 0, 1, 1, 1, 1, 1, 1, 1, 0};
static const casadi_int casadi_s6[11] = {1, 7, 0, 0, 1, 1, 1, 1, 1, 1, 0};
static const casadi_int casadi_s7[11] = {1, 7, 0, 0, 0, 1, 1, 1, 1, 1, 0};
static const casadi_int casadi_s8[11] = {1, 7, 0, 0, 0, 0, 1, 1, 1, 1, 0};
static const casadi_int casadi_s9[11] = {1, 7, 0, 0, 0, 0, 0, 1, 1, 1, 0};
static const casadi_int casadi_s10[11] = {1, 7, 0, 0, 0, 0, 0, 0, 1, 1, 0};
static const casadi_int casadi_s11[11] = {1, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0};
static const casadi_int casadi_s12[38] = {7, 7, 0, 1, 3, 6, 10, 15, 21, 28, 0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6};
static const casadi_int casadi_s13[11] = {7, 1, 0, 7, 0, 1, 2, 3, 4, 5, 6};
static const casadi_int casadi_s14[5] = {1, 1, 0, 1, 0};

/* nlp_grad:(x[7],p[64],lam_f,lam_g[8])->(f,g[8],grad_gamma_x[7],grad_gamma_p[64]) */
static int casadi_f2(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i, j, k;
  casadi_real *rr, *ss, *tt;
  const casadi_real *cs;
  casadi_real w0, w1, *w2=w+9, *w3=w+16, *w4=w+23, *w5=w+30, w6, *w7=w+80, *w8=w+87, *w9=w+95, *w10=w+102, *w12=w+151, *w13=w+214;
  /* #0: @0 = 0.5 */
  w0 = 5.0000000000000000e-01;
  /* #1: @1 = 0 */
  w1 = 0.;
  /* #2: @2 = zeros(1x7) */
  casadi_clear(w2, 7);
  /* #3: @3 = input[0][0] */
  casadi_copy(arg[0], 7, w3);
  /* #4: @4 = @3' */
  casadi_copy(w3, 7, w4);
  /* #5: @5 = input[1][0] */
  casadi_copy(arg[1], 49, w5);
  /* #6: @2 = mac(@4,@5,@2) */
  for (i=0, rr=w2; i<7; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w4+j, tt=w5+i*7; k<7; ++k) *rr += ss[k*1]**tt++;
  /* #7: @1 = mac(@2,@3,@1) */
  for (i=0, rr=(&w1); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w2+j, tt=w3+i*7; k<7; ++k) *rr += ss[k*1]**tt++;
  /* #8: @1 = (@0*@1) */
  w1  = (w0*w1);
  /* #9: @6 = 0 */
  w6 = 0.;
  /* #10: @4 = input[1][1] */
  casadi_copy(arg[1] ? arg[1]+49 : 0, 7, w4);
  /* #11: @7 = @4' */
  casadi_copy(w4, 7, w7);
  /* #12: @6 = mac(@7,@3,@6) */
  for (i=0, rr=(&w6); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w7+j, tt=w3+i*7; k<7; ++k) *rr += ss[k*1]**tt++;
  /* #13: @1 = (@1+@6) */
  w1 += w6;
  /* #14: output[0][0] = @1 */
  if (res[0]) res[0][0] = w1;
  /* #15: @1 = 0 */
  w1 = 0.;
  /* #16: @7 = input[1][2] */
  casadi_copy(arg[1] ? arg[1]+56 : 0, 7, w7);
  /* #17: @1 = mac(@7,@3,@1) */
  for (i=0, rr=(&w1); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w7+j, tt=w3+i*7; k<7; ++k) *rr += ss[k*1]**tt++;
  /* #18: output[1][0] = @1 */
  if (res[1]) res[1][0] = w1;
  /* #19: output[1][1] = @3 */
  if (res[1]) casadi_copy(w3, 7, res[1]+1);
  /* #20: @8 = input[3][0] */
  casadi_copy(arg[3], 8, w8);
  /* #21: {@1, @9} = vertsplit(@8) */
  w1 = w8[0];
  casadi_copy(w8+1, 7, w9);
  /* #22: @7 = @7' */
  /* #23: @7 = (@7*@1) */
  for (i=0, rr=w7; i<7; ++i) (*rr++) *= w1;
  /* #24: @9 = (@9+@7) */
  for (i=0, rr=w9, cs=w7; i<7; ++i) (*rr++) += (*cs++);
  /* #25: @1 = input[2][0] */
  w1 = arg[2] ? arg[2][0] : 0;
  /* #26: @4 = (@4*@1) */
  for (i=0, rr=w4; i<7; ++i) (*rr++) *= w1;
  /* #27: @9 = (@9+@4) */
  for (i=0, rr=w9, cs=w4; i<7; ++i) (*rr++) += (*cs++);
  /* #28: @2 = @2' */
  /* #29: @6 = (@0*@1) */
  w6  = (w0*w1);
  /* #30: @2 = (@2*@6) */
  for (i=0, rr=w2; i<7; ++i) (*rr++) *= w6;
  /* #31: @9 = (@9+@2) */
  for (i=0, rr=w9, cs=w2; i<7; ++i) (*rr++) += (*cs++);
  /* #32: @2 = zeros(1x7) */
  casadi_clear(w2, 7);
  /* #33: @4 = @3' */
  casadi_copy(w3, 7, w4);
  /* #34: @4 = (@6*@4) */
  for (i=0, rr=w4, cs=w4; i<7; ++i) (*rr++)  = (w6*(*cs++));
  /* #35: @10 = @5' */
  for (i=0, rr=w10, cs=w5; i<7; ++i) for (j=0; j<7; ++j) rr[i+j*7] = *cs++;
  /* #36: @2 = mac(@4,@10,@2) */
  for (i=0, rr=w2; i<7; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w4+j, tt=w10+i*7; k<7; ++k) *rr += ss[k*1]**tt++;
  /* #37: @2 = @2' */
  /* #38: @9 = (@9+@2) */
  for (i=0, rr=w9, cs=w2; i<7; ++i) (*rr++) += (*cs++);
  /* #39: output[2][0] = @9 */
  casadi_copy(w9, 7, res[2]);
  /* #40: @10 = zeros(7x7) */
  casadi_clear(w10, 49);
  /* #41: @0 = (@0*@1) */
  w0 *= w1;
  /* #42: @9 = @3' */
  casadi_copy(w3, 7, w9);
  /* #43: @9 = (@0*@9) */
  for (i=0, rr=w9, cs=w9; i<7; ++i) (*rr++)  = (w0*(*cs++));
  /* #44: @10 = mac(@3,@9,@10) */
  for (i=0, rr=w10; i<7; ++i) for (j=0; j<7; ++j, ++rr) for (k=0, ss=w3+j, tt=w9+i*1; k<1; ++k) *rr += ss[k*7]**tt++;
  /* #45: @10 = vec(@10) */
  /* #46: @9 = @3' */
  casadi_copy(w3, 7, w9);
  /* #47: @9 = (@1*@9) */
  for (i=0, rr=w9, cs=w9; i<7; ++i) (*rr++)  = (w1*(*cs++));
  /* #48: @9 = @9' */
  /* #49: {@1, NULL} = vertsplit(@8) */
  w1 = w8[0];
  /* #50: @3 = @3' */
  /* #51: @3 = (@1*@3) */
  for (i=0, rr=w3, cs=w3; i<7; ++i) (*rr++)  = (w1*(*cs++));
  /* #52: @3 = @3' */
  /* #53: @11 = 00 */
  /* #54: @12 = vertcat(@10, @9, @3, @11) */
  rr=w12;
  for (i=0, cs=w10; i<49; ++i) *rr++ = *cs++;
  for (i=0, cs=w9; i<7; ++i) *rr++ = *cs++;
  for (i=0, cs=w3; i<7; ++i) *rr++ = *cs++;
  /* #55: @13 = dense(@12) */
  casadi_densify(w12, casadi_s0, w13, 0);
  /* #56: output[3][0] = @13 */
  casadi_copy(w13, 64, res[3]);
  return 0;
}

/* nlp_f:(x[7],p[64])->(f) */
static int casadi_f3(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i, j, k;
  casadi_real *rr, *ss, *tt;
  casadi_real w0, w1, *w2=w+3, *w3=w+10, *w4=w+17, *w5=w+24;
  /* #0: @0 = 0.5 */
  w0 = 5.0000000000000000e-01;
  /* #1: @1 = 0 */
  w1 = 0.;
  /* #2: @2 = zeros(1x7) */
  casadi_clear(w2, 7);
  /* #3: @3 = input[0][0] */
  casadi_copy(arg[0], 7, w3);
  /* #4: @4 = @3' */
  casadi_copy(w3, 7, w4);
  /* #5: @5 = input[1][0] */
  casadi_copy(arg[1], 49, w5);
  /* #6: @2 = mac(@4,@5,@2) */
  for (i=0, rr=w2; i<7; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w4+j, tt=w5+i*7; k<7; ++k) *rr += ss[k*1]**tt++;
  /* #7: @1 = mac(@2,@3,@1) */
  for (i=0, rr=(&w1); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w2+j, tt=w3+i*7; k<7; ++k) *rr += ss[k*1]**tt++;
  /* #8: @0 = (@0*@1) */
  w0 *= w1;
  /* #9: @1 = 0 */
  w1 = 0.;
  /* #10: @2 = input[1][1] */
  casadi_copy(arg[1] ? arg[1]+49 : 0, 7, w2);
  /* #11: @2 = @2' */
  /* #12: @1 = mac(@2,@3,@1) */
  for (i=0, rr=(&w1); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w2+j, tt=w3+i*7; k<7; ++k) *rr += ss[k*1]**tt++;
  /* #13: @0 = (@0+@1) */
  w0 += w1;
  /* #14: output[0][0] = @0 */
  if (res[0]) res[0][0] = w0;
  return 0;
}

/* nlp_grad_f:(x[7],p[64])->(f,grad_f_x[7]) */
static int casadi_f4(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i, j, k;
  casadi_real *rr, *ss, *tt;
  const casadi_real *cs;
  casadi_real w0, w1, *w2=w+3, *w3=w+10, *w4=w+17, *w5=w+24, *w6=w+73, *w7=w+80;
  /* #0: @0 = 0.5 */
  w0 = 5.0000000000000000e-01;
  /* #1: @1 = 0 */
  w1 = 0.;
  /* #2: @2 = zeros(1x7) */
  casadi_clear(w2, 7);
  /* #3: @3 = input[0][0] */
  casadi_copy(arg[0], 7, w3);
  /* #4: @4 = @3' */
  casadi_copy(w3, 7, w4);
  /* #5: @5 = input[1][0] */
  casadi_copy(arg[1], 49, w5);
  /* #6: @2 = mac(@4,@5,@2) */
  for (i=0, rr=w2; i<7; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w4+j, tt=w5+i*7; k<7; ++k) *rr += ss[k*1]**tt++;
  /* #7: @1 = mac(@2,@3,@1) */
  for (i=0, rr=(&w1); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w2+j, tt=w3+i*7; k<7; ++k) *rr += ss[k*1]**tt++;
  /* #8: @0 = (@0*@1) */
  w0 *= w1;
  /* #9: @1 = 0 */
  w1 = 0.;
  /* #10: @4 = input[1][1] */
  casadi_copy(arg[1] ? arg[1]+49 : 0, 7, w4);
  /* #11: @6 = @4' */
  casadi_copy(w4, 7, w6);
  /* #12: @1 = mac(@6,@3,@1) */
  for (i=0, rr=(&w1); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w6+j, tt=w3+i*7; k<7; ++k) *rr += ss[k*1]**tt++;
  /* #13: @0 = (@0+@1) */
  w0 += w1;
  /* #14: output[0][0] = @0 */
  if (res[0]) res[0][0] = w0;
  /* #15: @0 = 0.5 */
  w0 = 5.0000000000000000e-01;
  /* #16: @2 = @2' */
  /* #17: @2 = (@0*@2) */
  for (i=0, rr=w2, cs=w2; i<7; ++i) (*rr++)  = (w0*(*cs++));
  /* #18: @4 = (@4+@2) */
  for (i=0, rr=w4, cs=w2; i<7; ++i) (*rr++) += (*cs++);
  /* #19: @2 = zeros(1x7) */
  casadi_clear(w2, 7);
  /* #20: @3 = @3' */
  /* #21: @3 = (@0*@3) */
  for (i=0, rr=w3, cs=w3; i<7; ++i) (*rr++)  = (w0*(*cs++));
  /* #22: @7 = @5' */
  for (i=0, rr=w7, cs=w5; i<7; ++i) for (j=0; j<7; ++j) rr[i+j*7] = *cs++;
  /* #23: @2 = mac(@3,@7,@2) */
  for (i=0, rr=w2; i<7; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w3+j, tt=w7+i*7; k<7; ++k) *rr += ss[k*1]**tt++;
  /* #24: @2 = @2' */
  /* #25: @4 = (@4+@2) */
  for (i=0, rr=w4, cs=w2; i<7; ++i) (*rr++) += (*cs++);
  /* #26: output[1][0] = @4 */
  casadi_copy(w4, 7, res[1]);
  return 0;
}

/* nlp_g:(x[7],p[64])->(g[8]) */
static int casadi_f5(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i, j, k;
  casadi_real *rr, *ss, *tt;
  casadi_real w0, *w1=w+2, *w2=w+9;
  /* #0: @0 = 0 */
  w0 = 0.;
  /* #1: @1 = input[1][2] */
  casadi_copy(arg[1] ? arg[1]+56 : 0, 7, w1);
  /* #2: @2 = input[0][0] */
  casadi_copy(arg[0], 7, w2);
  /* #3: @0 = mac(@1,@2,@0) */
  for (i=0, rr=(&w0); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w1+j, tt=w2+i*7; k<7; ++k) *rr += ss[k*1]**tt++;
  /* #4: output[0][0] = @0 */
  if (res[0]) res[0][0] = w0;
  /* #5: output[0][1] = @2 */
  if (res[0]) casadi_copy(w2, 7, res[0]+1);
  return 0;
}

/* nlp_jac_g:(x[7],p[64])->(g[8],jac_g_x[8x7,14nz]) */
static int casadi_f6(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i, j, k;
  casadi_real *rr, *ss, *tt;
  casadi_real w0, *w1=w+2, *w2=w+9, *w3=w+16, w4, *w5=w+31;
  /* #0: @0 = 0 */
  w0 = 0.;
  /* #1: @1 = input[1][2] */
  casadi_copy(arg[1] ? arg[1]+56 : 0, 7, w1);
  /* #2: @2 = input[0][0] */
  casadi_copy(arg[0], 7, w2);
  /* #3: @0 = mac(@1,@2,@0) */
  for (i=0, rr=(&w0); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w1+j, tt=w2+i*7; k<7; ++k) *rr += ss[k*1]**tt++;
  /* #4: output[0][0] = @0 */
  if (res[0]) res[0][0] = w0;
  /* #5: output[0][1] = @2 */
  if (res[0]) casadi_copy(w2, 7, res[0]+1);
  /* #6: @3 = zeros(7x8,14nz) */
  casadi_clear(w3, 14);
  /* #7: @1 = @1' */
  /* #8: @0 = ones(8x1,1nz) */
  w0 = 1.;
  /* #9: {@4, NULL} = vertsplit(@0) */
  w4 = w0;
  /* #10: @1 = (@1*@4) */
  for (i=0, rr=w1; i<7; ++i) (*rr++) *= w4;
  /* #11: @4 = @1[0] */
  for (rr=(&w4), ss=w1+0; ss!=w1+1; ss+=1) *rr++ = *ss;
  /* #12: (@3[0] = @4) */
  for (rr=w3+0, ss=(&w4); rr!=w3+1; rr+=1) *rr = *ss++;
  /* #13: @4 = @1[1] */
  for (rr=(&w4), ss=w1+1; ss!=w1+2; ss+=1) *rr++ = *ss;
  /* #14: (@3[1] = @4) */
  for (rr=w3+1, ss=(&w4); rr!=w3+2; rr+=1) *rr = *ss++;
  /* #15: @4 = @1[2] */
  for (rr=(&w4), ss=w1+2; ss!=w1+3; ss+=1) *rr++ = *ss;
  /* #16: (@3[2] = @4) */
  for (rr=w3+2, ss=(&w4); rr!=w3+3; rr+=1) *rr = *ss++;
  /* #17: @4 = @1[3] */
  for (rr=(&w4), ss=w1+3; ss!=w1+4; ss+=1) *rr++ = *ss;
  /* #18: (@3[3] = @4) */
  for (rr=w3+3, ss=(&w4); rr!=w3+4; rr+=1) *rr = *ss++;
  /* #19: @4 = @1[4] */
  for (rr=(&w4), ss=w1+4; ss!=w1+5; ss+=1) *rr++ = *ss;
  /* #20: (@3[4] = @4) */
  for (rr=w3+4, ss=(&w4); rr!=w3+5; rr+=1) *rr = *ss++;
  /* #21: @4 = @1[5] */
  for (rr=(&w4), ss=w1+5; ss!=w1+6; ss+=1) *rr++ = *ss;
  /* #22: (@3[5] = @4) */
  for (rr=w3+5, ss=(&w4); rr!=w3+6; rr+=1) *rr = *ss++;
  /* #23: @4 = @1[6] */
  for (rr=(&w4), ss=w1+6; ss!=w1+7; ss+=1) *rr++ = *ss;
  /* #24: (@3[6] = @4) */
  for (rr=w3+6, ss=(&w4); rr!=w3+7; rr+=1) *rr = *ss++;
  /* #25: @1 = ones(8x1,7nz) */
  casadi_fill(w1, 7, 1.);
  /* #26: {NULL, @2} = vertsplit(@1) */
  casadi_copy(w1, 7, w2);
  /* #27: @4 = @2[0] */
  for (rr=(&w4), ss=w2+0; ss!=w2+1; ss+=1) *rr++ = *ss;
  /* #28: (@3[7] = @4) */
  for (rr=w3+7, ss=(&w4); rr!=w3+8; rr+=1) *rr = *ss++;
  /* #29: @4 = @2[1] */
  for (rr=(&w4), ss=w2+1; ss!=w2+2; ss+=1) *rr++ = *ss;
  /* #30: (@3[8] = @4) */
  for (rr=w3+8, ss=(&w4); rr!=w3+9; rr+=1) *rr = *ss++;
  /* #31: @4 = @2[2] */
  for (rr=(&w4), ss=w2+2; ss!=w2+3; ss+=1) *rr++ = *ss;
  /* #32: (@3[9] = @4) */
  for (rr=w3+9, ss=(&w4); rr!=w3+10; rr+=1) *rr = *ss++;
  /* #33: @4 = @2[3] */
  for (rr=(&w4), ss=w2+3; ss!=w2+4; ss+=1) *rr++ = *ss;
  /* #34: (@3[10] = @4) */
  for (rr=w3+10, ss=(&w4); rr!=w3+11; rr+=1) *rr = *ss++;
  /* #35: @4 = @2[4] */
  for (rr=(&w4), ss=w2+4; ss!=w2+5; ss+=1) *rr++ = *ss;
  /* #36: (@3[11] = @4) */
  for (rr=w3+11, ss=(&w4); rr!=w3+12; rr+=1) *rr = *ss++;
  /* #37: @4 = @2[5] */
  for (rr=(&w4), ss=w2+5; ss!=w2+6; ss+=1) *rr++ = *ss;
  /* #38: (@3[12] = @4) */
  for (rr=w3+12, ss=(&w4); rr!=w3+13; rr+=1) *rr = *ss++;
  /* #39: @4 = @2[6] */
  for (rr=(&w4), ss=w2+6; ss!=w2+7; ss+=1) *rr++ = *ss;
  /* #40: (@3[13] = @4) */
  for (rr=w3+13, ss=(&w4); rr!=w3+14; rr+=1) *rr = *ss++;
  /* #41: @5 = @3' */
  casadi_trans(w3,casadi_s2, w5, casadi_s1, iw);
  /* #42: output[1][0] = @5 */
  casadi_copy(w5, 14, res[1]);
  return 0;
}

/* nlp_hess_l:(x[7],p[64],lam_f,lam_g[8])->(triu_hess_gamma_x_x[7x7,28nz]) */
static int casadi_f7(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i, j;
  casadi_real *rr, *ss;
  const casadi_real *cs;
  casadi_real *w0=w+1, w1, w2, *w3=w+52, *w4=w+59, *w5=w+108, *w6=w+115, *w7=w+164;
  /* #0: @0 = zeros(7x7) */
  casadi_clear(w0, 49);
  /* #1: @1 = 0.5 */
  w1 = 5.0000000000000000e-01;
  /* #2: @2 = input[2][0] */
  w2 = arg[2] ? arg[2][0] : 0;
  /* #3: @1 = (@1*@2) */
  w1 *= w2;
  /* #4: @3 = zeros(1x7) */
  casadi_clear(w3, 7);
  /* #5: @2 = ones(1x7,1nz) */
  w2 = 1.;
  /* #6: @4 = input[1][0] */
  casadi_copy(arg[1], 49, w4);
  /* #7: @3 = mac(@2,@4,@3) */
  casadi_mtimes((&w2), casadi_s5, w4, casadi_s4, w3, casadi_s3, w, 0);
  /* #8: @3 = @3' */
  /* #9: @3 = (@1*@3) */
  for (i=0, rr=w3, cs=w3; i<7; ++i) (*rr++)  = (w1*(*cs++));
  /* #10: @5 = zeros(1x7) */
  casadi_clear(w5, 7);
  /* #11: @2 = sparsity_cast(@1) */
  casadi_copy((&w1), 1, (&w2));
  /* #12: @6 = @4' */
  for (i=0, rr=w6, cs=w4; i<7; ++i) for (j=0; j<7; ++j) rr[i+j*7] = *cs++;
  /* #13: @5 = mac(@2,@6,@5) */
  casadi_mtimes((&w2), casadi_s5, w6, casadi_s4, w5, casadi_s3, w, 0);
  /* #14: @5 = @5' */
  /* #15: @3 = (@3+@5) */
  for (i=0, rr=w3, cs=w5; i<7; ++i) (*rr++) += (*cs++);
  /* #16: (@0[:7] = @3) */
  for (rr=w0+0, ss=w3; rr!=w0+7; rr+=1) *rr = *ss++;
  /* #17: (@0[:49:7] = @3) */
  for (rr=w0+0, ss=w3; rr!=w0+49; rr+=7) *rr = *ss++;
  /* #18: @3 = zeros(1x7) */
  casadi_clear(w3, 7);
  /* #19: @2 = ones(1x7,1nz) */
  w2 = 1.;
  /* #20: @3 = mac(@2,@4,@3) */
  casadi_mtimes((&w2), casadi_s6, w4, casadi_s4, w3, casadi_s3, w, 0);
  /* #21: @3 = @3' */
  /* #22: @3 = (@1*@3) */
  for (i=0, rr=w3, cs=w3; i<7; ++i) (*rr++)  = (w1*(*cs++));
  /* #23: @5 = zeros(1x7) */
  casadi_clear(w5, 7);
  /* #24: @2 = sparsity_cast(@1) */
  casadi_copy((&w1), 1, (&w2));
  /* #25: @5 = mac(@2,@6,@5) */
  casadi_mtimes((&w2), casadi_s6, w6, casadi_s4, w5, casadi_s3, w, 0);
  /* #26: @5 = @5' */
  /* #27: @3 = (@3+@5) */
  for (i=0, rr=w3, cs=w5; i<7; ++i) (*rr++) += (*cs++);
  /* #28: (@0[7:14] = @3) */
  for (rr=w0+7, ss=w3; rr!=w0+14; rr+=1) *rr = *ss++;
  /* #29: (@0[1:50:7] = @3) */
  for (rr=w0+1, ss=w3; rr!=w0+50; rr+=7) *rr = *ss++;
  /* #30: @3 = zeros(1x7) */
  casadi_clear(w3, 7);
  /* #31: @2 = ones(1x7,1nz) */
  w2 = 1.;
  /* #32: @3 = mac(@2,@4,@3) */
  casadi_mtimes((&w2), casadi_s7, w4, casadi_s4, w3, casadi_s3, w, 0);
  /* #33: @3 = @3' */
  /* #34: @3 = (@1*@3) */
  for (i=0, rr=w3, cs=w3; i<7; ++i) (*rr++)  = (w1*(*cs++));
  /* #35: @5 = zeros(1x7) */
  casadi_clear(w5, 7);
  /* #36: @2 = sparsity_cast(@1) */
  casadi_copy((&w1), 1, (&w2));
  /* #37: @5 = mac(@2,@6,@5) */
  casadi_mtimes((&w2), casadi_s7, w6, casadi_s4, w5, casadi_s3, w, 0);
  /* #38: @5 = @5' */
  /* #39: @3 = (@3+@5) */
  for (i=0, rr=w3, cs=w5; i<7; ++i) (*rr++) += (*cs++);
  /* #40: (@0[14:21] = @3) */
  for (rr=w0+14, ss=w3; rr!=w0+21; rr+=1) *rr = *ss++;
  /* #41: (@0[2:51:7] = @3) */
  for (rr=w0+2, ss=w3; rr!=w0+51; rr+=7) *rr = *ss++;
  /* #42: @3 = zeros(1x7) */
  casadi_clear(w3, 7);
  /* #43: @2 = ones(1x7,1nz) */
  w2 = 1.;
  /* #44: @3 = mac(@2,@4,@3) */
  casadi_mtimes((&w2), casadi_s8, w4, casadi_s4, w3, casadi_s3, w, 0);
  /* #45: @3 = @3' */
  /* #46: @3 = (@1*@3) */
  for (i=0, rr=w3, cs=w3; i<7; ++i) (*rr++)  = (w1*(*cs++));
  /* #47: @5 = zeros(1x7) */
  casadi_clear(w5, 7);
  /* #48: @2 = sparsity_cast(@1) */
  casadi_copy((&w1), 1, (&w2));
  /* #49: @5 = mac(@2,@6,@5) */
  casadi_mtimes((&w2), casadi_s8, w6, casadi_s4, w5, casadi_s3, w, 0);
  /* #50: @5 = @5' */
  /* #51: @3 = (@3+@5) */
  for (i=0, rr=w3, cs=w5; i<7; ++i) (*rr++) += (*cs++);
  /* #52: (@0[21:28] = @3) */
  for (rr=w0+21, ss=w3; rr!=w0+28; rr+=1) *rr = *ss++;
  /* #53: (@0[3:52:7] = @3) */
  for (rr=w0+3, ss=w3; rr!=w0+52; rr+=7) *rr = *ss++;
  /* #54: @3 = zeros(1x7) */
  casadi_clear(w3, 7);
  /* #55: @2 = ones(1x7,1nz) */
  w2 = 1.;
  /* #56: @3 = mac(@2,@4,@3) */
  casadi_mtimes((&w2), casadi_s9, w4, casadi_s4, w3, casadi_s3, w, 0);
  /* #57: @3 = @3' */
  /* #58: @3 = (@1*@3) */
  for (i=0, rr=w3, cs=w3; i<7; ++i) (*rr++)  = (w1*(*cs++));
  /* #59: @5 = zeros(1x7) */
  casadi_clear(w5, 7);
  /* #60: @2 = sparsity_cast(@1) */
  casadi_copy((&w1), 1, (&w2));
  /* #61: @5 = mac(@2,@6,@5) */
  casadi_mtimes((&w2), casadi_s9, w6, casadi_s4, w5, casadi_s3, w, 0);
  /* #62: @5 = @5' */
  /* #63: @3 = (@3+@5) */
  for (i=0, rr=w3, cs=w5; i<7; ++i) (*rr++) += (*cs++);
  /* #64: (@0[28:35] = @3) */
  for (rr=w0+28, ss=w3; rr!=w0+35; rr+=1) *rr = *ss++;
  /* #65: (@0[4:53:7] = @3) */
  for (rr=w0+4, ss=w3; rr!=w0+53; rr+=7) *rr = *ss++;
  /* #66: @3 = zeros(1x7) */
  casadi_clear(w3, 7);
  /* #67: @2 = ones(1x7,1nz) */
  w2 = 1.;
  /* #68: @3 = mac(@2,@4,@3) */
  casadi_mtimes((&w2), casadi_s10, w4, casadi_s4, w3, casadi_s3, w, 0);
  /* #69: @3 = @3' */
  /* #70: @3 = (@1*@3) */
  for (i=0, rr=w3, cs=w3; i<7; ++i) (*rr++)  = (w1*(*cs++));
  /* #71: @5 = zeros(1x7) */
  casadi_clear(w5, 7);
  /* #72: @2 = sparsity_cast(@1) */
  casadi_copy((&w1), 1, (&w2));
  /* #73: @5 = mac(@2,@6,@5) */
  casadi_mtimes((&w2), casadi_s10, w6, casadi_s4, w5, casadi_s3, w, 0);
  /* #74: @5 = @5' */
  /* #75: @3 = (@3+@5) */
  for (i=0, rr=w3, cs=w5; i<7; ++i) (*rr++) += (*cs++);
  /* #76: (@0[35:42] = @3) */
  for (rr=w0+35, ss=w3; rr!=w0+42; rr+=1) *rr = *ss++;
  /* #77: (@0[5:54:7] = @3) */
  for (rr=w0+5, ss=w3; rr!=w0+54; rr+=7) *rr = *ss++;
  /* #78: @3 = zeros(1x7) */
  casadi_clear(w3, 7);
  /* #79: @2 = ones(1x7,1nz) */
  w2 = 1.;
  /* #80: @3 = mac(@2,@4,@3) */
  casadi_mtimes((&w2), casadi_s11, w4, casadi_s4, w3, casadi_s3, w, 0);
  /* #81: @3 = @3' */
  /* #82: @3 = (@1*@3) */
  for (i=0, rr=w3, cs=w3; i<7; ++i) (*rr++)  = (w1*(*cs++));
  /* #83: @5 = zeros(1x7) */
  casadi_clear(w5, 7);
  /* #84: @1 = sparsity_cast(@1) */
  /* #85: @5 = mac(@1,@6,@5) */
  casadi_mtimes((&w1), casadi_s11, w6, casadi_s4, w5, casadi_s3, w, 0);
  /* #86: @5 = @5' */
  /* #87: @3 = (@3+@5) */
  for (i=0, rr=w3, cs=w5; i<7; ++i) (*rr++) += (*cs++);
  /* #88: (@0[42:49] = @3) */
  for (rr=w0+42, ss=w3; rr!=w0+49; rr+=1) *rr = *ss++;
  /* #89: (@0[6:55:7] = @3) */
  for (rr=w0+6, ss=w3; rr!=w0+55; rr+=7) *rr = *ss++;
  /* #90: @6 = @0' */
  for (i=0, rr=w6, cs=w0; i<7; ++i) for (j=0; j<7; ++j) rr[i+j*7] = *cs++;
  /* #91: @7 = project(@6) */
  casadi_sparsify(w6, w7, casadi_s12, 0);
  /* #92: output[0][0] = @7 */
  casadi_copy(w7, 28, res[0]);
  return 0;
}

bool casadi_nlp_f0(ipindex n, ipnumber *x, bool new_x, ipnumber *obj_value, UserDataPtr user_data) {
  struct casadi_ipopt_data* d = (struct casadi_ipopt_data*) user_data;
  d->arg[0] = x;
  d->arg[1] = d->nlp->p;
  d->res[0] = obj_value;
  if (casadi_f3(d->arg, d->res, d->iw, d->w, 0)) return false;
  return true;
}
bool casadi_nlp_g0(ipindex n, ipnumber *x, bool new_x, ipindex m, ipnumber *g, UserDataPtr user_data) {
  struct casadi_ipopt_data* d = (struct casadi_ipopt_data*) user_data;
  d->arg[0] = x;
  d->arg[1] = d->nlp->p;
  d->res[0] = g;
  if (casadi_f5(d->arg, d->res, d->iw, d->w, 0)) return false;
  return true;
}
bool casadi_nlp_grad_f0(ipindex n, ipnumber *x, bool new_x, ipnumber *grad_f, UserDataPtr user_data) {
  struct casadi_ipopt_data* d = (struct casadi_ipopt_data*) user_data;
  d->arg[0] = x;
  d->arg[1] = d->nlp->p;
  d->res[0] = 0;
  d->res[1] = grad_f;
  if (casadi_f4(d->arg, d->res, d->iw, d->w, 0)) return false;
  return true;
}
bool casadi_nlp_jac_g0(ipindex n, ipnumber *x, bool new_x, ipindex m, ipindex nele_jac, ipindex *iRow, ipindex *jCol, ipnumber *values, UserDataPtr user_data) {
  struct casadi_ipopt_data* d = (struct casadi_ipopt_data*) user_data;
  if (values) {
    d->arg[0] = x;
    d->arg[1] = d->nlp->p;
    d->res[0] = 0;
    d->res[1] = values;
    if (casadi_f6(d->arg, d->res, d->iw, d->w, 0)) return false;
  } else {
    casadi_ipopt_sparsity(d->prob->sp_a, iRow, jCol);
  }
  return true;
}
bool casadi_nlp_hess_l0(ipindex n, ipnumber *x, bool new_x, ipnumber obj_factor,ipindex m, ipnumber *lambda, bool new_lambda, ipindex nele_hess, ipindex *iRow, ipindex *jCol, ipnumber *values, UserDataPtr user_data) {
  struct casadi_ipopt_data* d = (struct casadi_ipopt_data*) user_data;
  if (values) {
    d->arg[0] = x;
    d->arg[1] = d->nlp->p;
    d->arg[2] = &obj_factor;
    d->arg[3] = lambda;
    d->res[0] = values;
    if (casadi_f7(d->arg, d->res, d->iw, d->w, 0)) return false;
    return true;
  } else {
    casadi_ipopt_sparsity(d->prob->sp_h, iRow, jCol);
  }
  return true;
}
/* solver:(x0[7],p[64],lbx[7],ubx[7],lbg[8],ubg[8],lam_x0[7],lam_g0[8])->(x[7],f,g[8],lam_x[7],lam_g[8],lam_p[64]) */
static int casadi_f1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  const casadi_real one=1;
  struct casadi_ipopt_data* d=&casadi_f1_mem[mem];
  struct casadi_ipopt_prob p;
  struct casadi_nlpsol_data d_nlp;
  struct casadi_nlpsol_prob p_nlp;
  struct casadi_oracle_data d_oracle;
  d_nlp.oracle = &d_oracle;
  d_nlp.p = arg[1];
  d_nlp.lbx = arg[2];
  d_nlp.ubx = arg[3];
  d_nlp.lbg = arg[4];
  d_nlp.ubg = arg[5];
  d_nlp.x0 = arg[0];
  d_nlp.lam_x0 = arg[6];
  d_nlp.lam_g0 = arg[7];
  d_nlp.x = res[0];
  d_nlp.f = res[1];
  d_nlp.g = res[2];
  d_nlp.lam_x = res[3];
  d_nlp.lam_g = res[4];
  d_nlp.lam_p = res[5];
  d_nlp.prob = &p_nlp;
  p_nlp.nx = 7;
  p_nlp.ng = 8;
  p_nlp.np = 64;
  p_nlp.detect_bounds.ng = 0;
  casadi_nlpsol_init(&d_nlp, &arg, &res, &iw, &w);
  if (d_nlp.x0) {
    casadi_copy(d_nlp.x0, 7, d_nlp.z);
  } else {
    casadi_clear(d_nlp.z, 7);
  }
  if (d_nlp.lbx) {
    casadi_copy(d_nlp.lbx, 7, d_nlp.lbz);
  } else {
    casadi_fill(d_nlp.lbz, 7, -casadi_inf);
  }
  if (d_nlp.ubx) {
    casadi_copy(d_nlp.ubx, 7, d_nlp.ubz);
  } else {
    casadi_fill(d_nlp.ubz, 7, casadi_inf);
  }
  if (d_nlp.lam_x0) {
    casadi_copy(d_nlp.lam_x0, 7, d_nlp.lam);
  } else {
    casadi_clear(d_nlp.lam, 7);
  }
  if (d_nlp.lbg) {
    casadi_copy(d_nlp.lbg, 8, d_nlp.lbz+7);
  } else {
    casadi_fill(d_nlp.lbz+7, 8, -casadi_inf);
  }
  if (d_nlp.ubg) {
    casadi_copy(d_nlp.ubg, 8, d_nlp.ubz+7);
  } else {
    casadi_fill(d_nlp.ubz+7, 8, casadi_inf);
  }
  if (d_nlp.lam_g0) {
    casadi_copy(d_nlp.lam_g0, 8, d_nlp.lam+7);
  } else {
    casadi_clear(d_nlp.lam+7, 8);
  }
  d->nlp = &d_nlp;
  d->prob = &p;
  p.nlp = &p_nlp;
  p.sp_a = casadi_s1;
  p.sp_h = casadi_s12;
  casadi_ipopt_setup(&p);
  p.eval_f = casadi_nlp_f0;
  p.eval_g = casadi_nlp_g0;
  p.eval_grad_f = casadi_nlp_grad_f0;
  p.eval_jac_g = casadi_nlp_jac_g0;
  p.eval_h = casadi_nlp_hess_l0;
  casadi_ipopt_init(d, &arg, &res, &iw, &w);
  casadi_ipopt_presolve(d);
  AddIpoptStrOption(d->ipopt, "linear_solver","ma57");
  AddIpoptIntOption(d->ipopt, "max_iter",3000);
  AddIpoptIntOption(d->ipopt, "print_level",0);
  AddIpoptNumOption(d->ipopt, "tol",1e-08);
  casadi_ipopt_solve(d);
  d->arg[0] = d_nlp.z;
  d->arg[1] = d_nlp.p;
  d->arg[2] = &one;
  d->arg[3] = d_nlp.lam+7;
  d->res[0] = 0;
  d->res[1] = 0;
  d->res[2] = 0;
  d->res[3] = d_nlp.lam_p;
  if (casadi_f2(d->arg, d->res, d->iw, d->w, 0)) return 1;
  casadi_scal(64, -1.0, d_nlp.lam_p);
  casadi_copy(d_nlp.z, 7, d_nlp.x);
  casadi_copy(d_nlp.z + 7, 8, d_nlp.g);
  casadi_copy(d_nlp.lam, 7, d_nlp.lam_x);
  casadi_copy(d_nlp.lam + 7, 8, d_nlp.lam_g);
  if (d_nlp.f) casadi_copy(&d_nlp.objective, 1, d_nlp.f);
  if (d_nlp.lam_p) casadi_copy(d_nlp.lam_p, 64, d_nlp.lam_p);
  return 0;
  return 0;
}

int casadi_f1_alloc_mem(void) {
  return casadi_f1_mem_counter++;
}

int casadi_f1_init_mem(int mem) {
  ipopt_init_mem(&casadi_f1_mem[mem]);
  return 0;
}

void casadi_f1_free_mem(int mem) {
  ipopt_free_mem(&casadi_f1_mem[mem]);
}

int casadi_f1_checkout(void) {
  int mid;
  if (casadi_f1_unused_stack_counter>=0) {
    return casadi_f1_unused_stack[casadi_f1_unused_stack_counter--];
  } else {
    if (casadi_f1_mem_counter==CASADI_MAX_NUM_THREADS) return -1;
    mid = casadi_f1_alloc_mem();
    if (mid<0) return -1;
    if(casadi_f1_init_mem(mid)) return -1;
    return mid;
  }
}

void casadi_f1_release(int mem) {
  casadi_f1_unused_stack[++casadi_f1_unused_stack_counter] = mem;
}

/* helper:(i0[7],i1[64],i2[8])->(o0[7]) */
static int casadi_f8(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_real *w0=w+0;
  /* #0: @0 = input[0][0] */
  casadi_copy(arg[0], 7, w0);
  /* #1: output[0][0] = @0 */
  casadi_copy(w0, 7, res[0]);
  return 0;
}

/* cbf_solver:(i0[7x7],i1[7],i2[1x7],i3)->(o0[7]) */
static int casadi_f0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i;
  casadi_real **res1=res+1, *rr;
  const casadi_real **arg1=arg+4, *cs;
  int flag, mid;
  casadi_real *w0=w+395, *w1=w+402, *w2=w+451, *w3=w+458, w4, *w5=w+466, w6, w7, w8, w9, w10, w11, w12, w13, w14, *w15=w+539, *w16=w+546, *w17=w+553, *w18=w+561, *w19=w+569, *w20=w+577;
  /* #0: @0 = zeros(7x1) */
  casadi_clear(w0, 7);
  /* #1: @1 = input[0][0] */
  casadi_copy(arg[0], 49, w1);
  /* #2: @1 = vec(@1) */
  /* #3: @2 = input[1][0] */
  casadi_copy(arg[1], 7, w2);
  /* #4: @3 = input[2][0] */
  casadi_copy(arg[2], 7, w3);
  /* #5: @3 = @3' */
  /* #6: @4 = input[3][0] */
  w4 = arg[3] ? arg[3][0] : 0;
  /* #7: @5 = vertcat(@1, @2, @3, @4) */
  rr=w5;
  for (i=0, cs=w1; i<49; ++i) *rr++ = *cs++;
  for (i=0, cs=w2; i<7; ++i) *rr++ = *cs++;
  for (i=0, cs=w3; i<7; ++i) *rr++ = *cs++;
  *rr++ = w4;
  /* #8: @2 = -inf(7x1) */
  casadi_fill(w2, 7, -casadi_inf);
  /* #9: @3 = inf(7x1) */
  casadi_fill(w3, 7, casadi_inf);
  /* #10: @6 = -inf */
  w6 = -casadi_inf;
  /* #11: @7 = 0.8 */
  w7 = 8.0000000000000004e-01;
  /* #12: @8 = 87 */
  w8 = 87.;
  /* #13: @9 = 87 */
  w9 = 87.;
  /* #14: @10 = 87 */
  w10 = 87.;
  /* #15: @11 = 87 */
  w11 = 87.;
  /* #16: @12 = 12 */
  w12 = 12.;
  /* #17: @13 = 12 */
  w13 = 12.;
  /* #18: @14 = 12 */
  w14 = 12.;
  /* #19: @15 = vertcat(@8, @9, @10, @11, @12, @13, @14) */
  rr=w15;
  *rr++ = w8;
  *rr++ = w9;
  *rr++ = w10;
  *rr++ = w11;
  *rr++ = w12;
  *rr++ = w13;
  *rr++ = w14;
  /* #20: @15 = (@7*@15) */
  for (i=0, rr=w15, cs=w15; i<7; ++i) (*rr++)  = (w7*(*cs++));
  /* #21: @16 = (-@15) */
  for (i=0, rr=w16, cs=w15; i<7; ++i) *rr++ = (- *cs++ );
  /* #22: @17 = vertcat(@6, @16) */
  rr=w17;
  *rr++ = w6;
  for (i=0, cs=w16; i<7; ++i) *rr++ = *cs++;
  /* #23: @18 = vertcat(@4, @15) */
  rr=w18;
  *rr++ = w4;
  for (i=0, cs=w15; i<7; ++i) *rr++ = *cs++;
  /* #24: @15 = zeros(7x1) */
  casadi_clear(w15, 7);
  /* #25: @19 = zeros(8x1) */
  casadi_clear(w19, 8);
  /* #26: {@16, NULL, NULL, NULL, @20, NULL} = solver(@0, @5, @2, @3, @17, @18, @15, @19) */
  arg1[0]=w0;
  arg1[1]=w5;
  arg1[2]=w2;
  arg1[3]=w3;
  arg1[4]=w17;
  arg1[5]=w18;
  arg1[6]=w15;
  arg1[7]=w19;
  res1[0]=w16;
  res1[1]=0;
  res1[2]=0;
  res1[3]=0;
  res1[4]=w20;
  res1[5]=0;
  mid = casadi_f1_checkout();
  if (mid<0) return 1;
  flag = casadi_f1(arg1, res1, iw, w, mid);
  casadi_f1_release(mid);
  if (flag) return 1;
  /* #27: @0 = helper(@16, @5, @20) */
  arg1[0]=w16;
  arg1[1]=w5;
  arg1[2]=w20;
  res1[0]=w0;
  if (casadi_f8(arg1, res1, iw, w, 0)) return 1;
  /* #28: output[0][0] = @0 */
  casadi_copy(w0, 7, res[0]);
  return 0;
}

CASADI_SYMBOL_EXPORT int cbf_solver(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
  return casadi_f0(arg, res, iw, w, mem);
}

CASADI_SYMBOL_EXPORT int cbf_solver_alloc_mem(void) {
  return 0;
}

CASADI_SYMBOL_EXPORT int cbf_solver_init_mem(int mem) {
  return 0;
}

CASADI_SYMBOL_EXPORT void cbf_solver_free_mem(int mem) {
}

CASADI_SYMBOL_EXPORT int cbf_solver_checkout(void) {
  return 0;
}

CASADI_SYMBOL_EXPORT void cbf_solver_release(int mem) {
}

CASADI_SYMBOL_EXPORT void cbf_solver_incref(void) {
}

CASADI_SYMBOL_EXPORT void cbf_solver_decref(void) {
}

CASADI_SYMBOL_EXPORT casadi_int cbf_solver_n_in(void) { return 4;}

CASADI_SYMBOL_EXPORT casadi_int cbf_solver_n_out(void) { return 1;}

CASADI_SYMBOL_EXPORT casadi_real cbf_solver_default_in(casadi_int i) {
  switch (i) {
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT const char* cbf_solver_name_in(casadi_int i) {
  switch (i) {
    case 0: return "i0";
    case 1: return "i1";
    case 2: return "i2";
    case 3: return "i3";
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT const char* cbf_solver_name_out(casadi_int i) {
  switch (i) {
    case 0: return "o0";
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT const casadi_int* cbf_solver_sparsity_in(casadi_int i) {
  switch (i) {
    case 0: return casadi_s4;
    case 1: return casadi_s13;
    case 2: return casadi_s3;
    case 3: return casadi_s14;
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT const casadi_int* cbf_solver_sparsity_out(casadi_int i) {
  switch (i) {
    case 0: return casadi_s13;
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT int cbf_solver_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
  if (sz_arg) *sz_arg = 20;
  if (sz_res) *sz_res = 13;
  if (sz_iw) *sz_iw = 8;
  if (sz_w) *sz_w = 585;
  return 0;
}

CASADI_SYMBOL_EXPORT int cbf_solver_work_bytes(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
  if (sz_arg) *sz_arg = 20*sizeof(const casadi_real*);
  if (sz_res) *sz_res = 13*sizeof(casadi_real*);
  if (sz_iw) *sz_iw = 8*sizeof(casadi_int);
  if (sz_w) *sz_w = 585*sizeof(casadi_real);
  return 0;
}


#ifdef __cplusplus
} /* extern "C" */
#endif
